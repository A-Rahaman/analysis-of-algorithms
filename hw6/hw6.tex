%%%%%latex preamble%%%%%
\documentclass[titlepage]{article}\usepackage[]{graphicx}\usepackage[]{color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
  \linewidth
  \else
  \Gin@nat@width
  \fi
}
\makeatother


\usepackage{listings}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Python,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\usepackage{alltt}
\usepackage[sc]{mathpazo}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=1.5cm,rmargin=1.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{url}
\usepackage[unicode=true,pdfusetitle,
  bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
{hyperref}
\hypersetup{pdfstartview={XYZ null null 1}}
\usepackage{float}
\usepackage{bm}
\usepackage{tikz}
 %changes default sectioning commands -> 1,a, etc.
%\usepackage{breakurl}
\renewcommand{\thesubsection}{(\alph{subsection})}
\renewcommand{\thesubsubsection}{\roman{subsection}.}
\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
%\usepackage[active,tightpage]{preview}
\usepackage{tikz}
%\PreviewEnvironment{tikzpicture}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
%%% Header and Footer %%% 
\lhead{}
\chead{\leftmark}
\rhead{}
\lfoot{Aaron Gonzales; Algorithms}
\cfoot{Homework 6}
\rfoot{Page \thepage\ of \pageref{LastPage}}
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}

\newtheorem{name}{Printed output}

\begin{document}

\title{Homework 6, CS561, Fall 2014}
\author{Aaron Gonzales}
\maketitle

\section{Naming Omicronians}
\begin{quote}
  \textbf{Omicronians reproduce asexually with each baby producing up to two
  other babies. A birth process results in a binary tree, where babies are
  assigned their names in teh folloowing way. The baby at the root of the tree
  is assigned the name ``J''. Then any baby that is a left child of a node with
  the name $\sigma$ receives the name $\sigma L$ and any baby that is the right
  child of that node receives the name $\sigma R$. \\*
  Your goal is to take a binary tree specifying a birth process and return the
  number of R's in the names of all babies.}
\end{quote}
\begin{itemize}
	\item \textbf{\emph{Example:} in the following tree, the names are J, JL,
	JR, JLL, JLR, JRL, JRR, so the total number of R's is 5.  }
\end{itemize}

\subsection{For a node $v$ let $n(v)$ be the number of nodes in the subtree
	rooted at $v$ and assume this value is stored at each node. For a node $v$
	let $f(v)$ be the number of R's in the names of nodes below $v$. For
	simplicity, if $v$ is NULL, let $f(v) = 0$ andl et $n(v) = 0$ Also, for a
	node $v$, let $l(v)$ (resp $r(v)$) be the left (resp. right ) child of $v$
	if it exists or NULL otherwise. Give a recurrence relation for $f(v)$.}
\subsubsection{answer:}
\vspace{5cm}

\subsection{Your friend Bender claims that once you have the recurrence
	relation, you can just write a recurasive algorithm for this problem in
	order to compute $f(r)$ where r is the root node. There's no need to bother
	with a dynamic program that stores the computed $f$ values at the nodes of
	the tree. Is Bender right? Explain in a couple of sentences.}
\subsubsection{answer:}
\vspace{5cm}



\subsection{The Omicronians have evolved!} 
\begin{quote}
  \textbf{Now they can reproduce both sexually
	and assexually: i.e., each node can have 1 or 2 parents. So a birth process
	is now a rooted directed graph without cycles. Now each node can have
	multiple names, one for each path from the root down to that node. A
	particular path determins a name in the same way as before: start with J at
	the root and add a L whenever a left edge is taken and a R whenever a right
	edge is taken. \\*
	Professor Farnsworth claims that the same recurrence relation from part a
	can be used for this problem. Bender claims that this problem can also be
	done recursively, without the dynamic programming approach of storing $f$
	values at intermediate nodes. Which if either of your friends are correct?
	Explain briefly.}
\end{quote}
\subsubsection{answer: }
\vspace{8cm}





\section{Bins, Probability, and Expectation}
\begin{quote}
  \textbf{There are two bins. Bin 1 initially has 3 white balls and 1 red ball.
  Bin 2 has 4 white balls. In every round, a ball is selected uniformly at
  random from each bin and these two balls are swapped. \\*
  Let $p_k$ be the prbability that the red ball is in bin 1 at the beginning of
  the $k$-th round.}
\end{quote}

\subsection{ Write a recurrence relation for $p_k$. }
\subsubsection{answer:}
\vspace{4cm}
\begin{align}
  f(k) = 
	\begin{cases}
          \text{if red ball is in the right bin: } & \frac{1}{4}\left(1 - f(k-1)\right) \\*
          \text{if red ball is in the left bin: }  & \frac{3}{4} \left( f(k-1) \right) \\*	
	\end{cases}
\end{align}

\vspace{8cm}


\subsection{Use the guess and check and proof by induction method to solve this
	recurrence, Don't forget to label BC, IH, and IS and clearly say where you
	are using the IH}.
\subsubsection{answer:}
\vspace{8cm}


\subsection{Assume you are paid one dollar for every round in which the red
	ball is in bin 1 and there are $m$ rounds. What is the expected number of
dollars you earn?}
\subsubsection{answer:}
\vspace{8cm}


\section{Tree Induction}
\begin{quote}
  \textbf{Prove via induction that any tree over n nodes has exactly $n-1$
  edges. }
\end{quote}

\subsubsection{answer:}

\newtheorem{mydef}{Theorem}

\begin{name}
  Any tree over $n$ nodes has exactly $n-1$ edges.
\end{name}


\begin{proof}
By induction on $n$. \\*
Let $E$ be the number of edges in a tree.

Base case: when $n =1$, clearly $e = 0$ (there are no other nodes in the tree).

Inductive hypothesis: \\*
The Theorem is true for all trees with fewer than $ n$ vertices.

Let $T$ be a tree with $n$ nodes and $e$ be an edge from a node $u$ to a node
$v$. Only one path exists between $u,v$ and that is $e$. As such, if we delete $e$, the
tree $T$ is disconnected. $T - e$ represents the tree $T$ without the edge $e$
which can be represented by two subcomponents of $T$, $T_1, T_2$. Each
subcomponent is a tree, and let $n_1,n_2$ be the number of nodes in each
subcomponent such that $n_1 + n_2 = n$. 

Inductive step: \\*
By the inductive hypothesis, the number of edges in $T_1, T_2$ are $n_1-1,
n_2-1$
respectively and it follows that the the tree $T$ has 
\[ E = n_1 -1 + n_2 -1 +1 = n_1 + n_2-1 = n-1 \]
  \qedhere
\end{proof}


\section{Claim 1 from SSSP}
\begin{quote}
\begin{itemize}
  \item \textbf{if $dist(v) \neq \infty $, then $dist(v)$ is the total weight
	of the predessor chain ending at $v$:
  \[ s \rightarrow \dots \rightarrow pred(pred(v)) \rightarrow pred(v) \rightarrow v \] }
  \item \textbf{This is easy to prove by induction on the number of edges in
	the path from $s$ to $v$.}
\end{itemize}
\end{quote}

\subsubsection{answer:}
\vspace{8cm}




\section{Claim 2 from SSSP}
\begin{quote}
\begin{itemize}
  \item \textbf{ If the algorithm halts, then $dist(v) \leq w(s \leadsto )$
	  for \emph{any} path $s \leadsto v$.}
  \item \textbf{This is easy to prove by induction on the number of edges in
	the path from $s$ to $v$.}
\end{itemize}
\end{quote}
\subsubsection{answer:}
\vspace{8cm}



\section{Problem 23-4: Alternative MST}

\begin{quote}
  \textbf{ In this problem, we give pseudocode for three different algorithms.
	Each one takes a connected graph and a weight function as input and returns
	a set of edges $T$ .  For each algorithm, either prove that $T$ is a
	minimum spanning tree or prove that $T$ is not a minimum spanning tree.
	Also describe the most efﬁcient implementation of each algorithm, whether or
	not it computes a minimum spanning tree.  }
\end{quote}

Before the problems, first a few definitions:

\theoremstyle{definition}
\begin{definition}{SpanningTree}
  A tree is a connected undirected graph with no cycles. It is a spanning tree
  of a graph $G$ if it spans $G$ (that is, it includes every vertex of $G$) and is a
  subgraph of $G$ (every edge in the tree belongs to $G$). A spanning tree of a
  connected graph $G$ can also be defined as a maximal set of edges of $G$ that
  contains no cycle, or as a minimal set of edges that connect all vertices.
  \footnote{verbatim from wikipedia, not from CLRS}
\end{definition}
\begin{definition}{Minimal}
  Minimum spanning tree. An edge-weighted graph is a graph where we associate
  weights or costs with each edge. A minimum spanning tree (MST) of an
  edge-weighted graph is a spanning tree whose weight (the sum of the weights
  of its edges) is no larger than the weight of any other spanning tree.
  \footnote{from princeton algs book}
\end{definition}


\subsection{}
\begin{lstlisting}
Maybe-MST-A(G, w)
	sort the edges into nonincreasing order of edge weights w
	T = E
	for each edge e, taken in nonincreasing order by weight
		if T-{e} is a connected graph
			T = T - {e}
	return T
\end{lstlisting}
\subsubsection{answer: }
\vspace{8cm}




\subsection{}
\begin{lstlisting}
Maybe-MST-B(G,w)
  T = null
  for each edge e, taken in arbitrary order
	  if union(T, {e}) has no cycles
		  T = union(T, {e})
	  return T
\end{lstlisting}
\subsubsection{answer: }

\vspace{8cm}


\subsection{}
\begin{lstlisting}
Maybe-MST-C(G,w)
  T = null
  for each edge e, taken in arbitrary order
	T = union(T, {e})
	if T has a cycle c
	  let e_prime be a maximum weight edge on c
	  T = T - {e_prime}
  return T
\end{lstlisting}
\subsubsection{answer:}

\vspace{8cm}

\section{Problem 24-2 Nesting Boxes}
\begin{quote}
  \textbf{a d-dimensional box with dimensions $(x_1, x_2, \dots x_d)$
	\textbf{nests} within another box with dimensions $(y_1, y_2, \dots y_d)$
	if there exists a permutation $\pi$ on $\{1,2\dots,d\}$ such that 
	$ x_{\pi(1)} < y_1, x_{\pi(2)} < y_2, \dots x_{\pi(d)} < y_d$.  }
\end{quote}

\subsection{Argue that the nesting relation is transitive.}
\subsubsection{answer:}
\vspace{5cm}


\subsection{Describe an efficient method to determine wether or not one
$d$-dimensional box nests inside another.}
\subsubsection{answer:}
\vspace{5cm}



\subsection{Suppose that you are given a set of $n$ $d$-dimensional boxes
  $\{B_1, B_2,\dots B_n\}$. Give an efficient algorithm to find the longest
  sequence $\langle B_{i_1}, B_{i_2},\dots B_{i_k}\rangle$ of boxes such that
  $B_{i_j}$ nests within  
  $B_{i_{j+1}}$ for $j = 1,2,\dots,k-1$. Express the running time of your
algorithm in terms of n and d.}
\subsubsection{answer:}
\vspace{5cm}

\section{Saia Trucking}
\begin{quote}
  \textbf{Saia Trucking is a very saftey concious (and algorithm loving)
  trucking company. They always try to find the safest route between any pair
of cities. They are thus faced with the following problem.}

\textbf{There is a graph $G = (V,E)$ where the vertices represent cities and the edges
represent roads. Each edge has a value associated with it that gives the
probability of safe transport on that edge i.e. the prbability that there will
be no accident when driving across that edge. The probability of safe transport
along any path in the gtraph is the product $\Pi$ of the probabilities of safe
transport on each edge in that path.}

\textbf{The Goal is to find a path from $s$ to $t$ that maximizes the probability of
safe transport. Describe an efficient algorithm to solve this problem.  }
\end{quote}
\subsubsection{answer:}
We have $s$ as our start node and $t$ as our destination. let $e(u,v)$ be the
edge from vertex $u \rightarrow v$. We want to maximuze the product of the
probabilities on the path such that the set of vertices $p = \langle v_0, v_1,
\dots, v_k \rangle$ where $v_0 = s, v_k = t$. We want

\[ p = max \prod_{i = 0}^{k} e(v_{i-1}, v_i) \]

If we log transform the edge weights, we can solf this problem easily. if we
define $w(e) = - log \, e(u,v)$ as the log transform of the edge weight, we can
change the problem to  a single-source shortest path problem as 

\[ p = min \sum_{i=1}^{k} w(v_{i-1}, v_i) \]

This is easily solved with Dijkstra's algorithm with the additional step of log
transforming the edges ($O(E)$). Using a fibbonacci-heap-backed min-priority
queue we can do this is total $O(|E| + |V| log |V|)$ time.


\newpage
\section{25.2-1 - Floyd\textemdash Warshall}
\begin{quote}
  \textbf{Run the Floyd\textemdash Warshall algorithm on the weighted, directed
	graph of Figure \ref{fig:figure1}. Show the matrix $D^{(k)}$ that results for each
	iteration of the outer loop.}
\end{quote}

\usetikzlibrary{arrows}
\begin{figure}
  \begin{center}
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
	  thick,main node/.style={circle,fill=blue!20,draw,font=\sffamily\Large\bfseries}]

	  \node[main node] (1) {1};
	  \node[main node] (2) [right of=1] {2};
	  \node[main node] (3) [right of=2] {3};
	  \node[main node] (4) [below of=1] {4};
	  \node[main node] (5) [right of=4] {5};
	  \node[main node] (6) [right of=5] {6};

	  \path[every node/.style={font=\sffamily\small}]
		(1) edge node [below right] {-1} (5)
			%edge [bend right] node[left] {0.3} (2)
			%edge [loop above] node {0.1} (1)
		(2) edge node [above] {1} (1)
			edge node [below left] {2} (4)
			%edge [loop left] node {0.4} (2)
			%edge [bend right] node[left] {0.1} (3)
		(3) edge node [above] {2} (2)
			edge [bend left] node[right] {-8} (6)
		(4) edge node [left] {-4} (1)
			%edge [loop right] node {0.6} (4)
			edge [bend right] node[below] {3} (5)
		(5) edge node [right] {7} (2)
			%edge [loop right] node {0.6} (4)
		(6) edge node [below] {5} (2)
			edge [bend left] node {10} (3);
	\end{tikzpicture}
  \end{center}
\caption{Figure 25.2 from CLRS}
\label{fig:figure1}
\end{figure}
\subsubsection{answer:}
\vspace{6cm}

\end{document}
